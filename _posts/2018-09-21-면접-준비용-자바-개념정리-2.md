---
layout: post
title: "면접 준비 용 자바 개념 정리 2"
tags: [java]
comments: true
---

## 1. 객체 지향 프로그래밍 특징
- 객체 지향 프로그래밍의 특징으로는 캡슐화, 상속, 다형성을 들 수 있다.

<br>
#### 1-1. 캡슐화
- 캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 자바 언어는 캡슐화 된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제한자(Access Modifier)를 사용한다. 접근 제한자는 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호한다.
<br>

#### 1-2. 상속
- 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다.
<br>

#### 1-3. 다형성
- 다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
- 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 그러나 예외가 있는데, 메소드가 자식 클래스에서 오버라이딩 되었다면 자식 클래스의 메소드가 대신 호출된다.
<br>

## 2. 강제 타입 변환(Casting)
- 강제 타입 변환(casting)은 부모 타입을 자식 타입으로 변환하는 것을 말한다. 물론 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니고, 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다
- 자식 타입이 부모 타입으로 자동 변환되면 부모 타입에 선언된 필드와 메소드만 사용 가능하다는 제약 사항이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면 된다.  

```
class Parant{
    String field1;
    void method1(){ ... }
    void method2(){ ... }
}

class Child extends Parent{
    String field2;
    void method3(){ ... }
}

class Example {
    public static void main(Sring[] args) {
        Parent parent = new Child();
        parent.field1 = "abc";
        parent.method1();
        parent.method2();

        parent.field2 = "def"; // (불가능)
        parent.method3();  // (불가능)

        Child child = (Child) parent;
        child.field2 = "def";
        child.method3();
    }
}

```
<br>
#### 2-1. 객체 타입 확인(instanceof)
- 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다
- 강제 타입 변환이 필요한 경우 반드시 매개값이 어떤 객체인지 instanceof 연산자로 확인하고 안전하게 강제 타입 변환을 해야한다  
- 타입을 확인하지 않고 강제 타입 변환을 시도하면 ClassCastException 예외가 발생 할 수 있다.

```
public void method(Parent parent){
    if(parent instanceof Child){
        Child child = (Child) parent;
    }
}
```

<br><br>
## 3. static
- static: '정적인, 고정인, 움직이지 않는'의 의미를 가진다. JVM 메모리에 고정됨을 뜻함과 동시에 모든 객체가 '공유'한다는 의미를 뜻한다. 때에 따라 모든 인스턴스가 같은 값을 공유하고 싶을 때가 있는데 이런 경우 static 키워드를 멤버변수 앞에 붙이면 클래스 소속의 변수가 된다. 물론 메소드도 마찬가지이다. static이 실행되는 시점은 클래스가 메모리 상에 올라갈 때 이며, static이 붙은 변수를 클래스 변수라고 하는 것은 변수가 존재하는 영역이 클래스가 존재하는 영역과 같기 때문이다.

<br>

#### 3-1. 싱글톤
- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우 사용
- 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 한다.
- 생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다
- 대신 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다  

```
public 클래스(){
    // 정적 필드
    private static 클래스 singleton = new 클래스();

    // 생성자
    private 생성자();

    // 정적 메소드
    public static 클래스 getInstance(){
        return singleton;
    }
}
```

<br><br>

## 4. final
- final이란 의미는 최종적이라는 뜻을 가지고 있다.
- final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 의미이다.
- 상속할 수 없는 final 클래스: 클래스를 선언할 때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 된다. final 클래스의 대표적인 예는 자바 표준 API에서 제공하는 String 클래스이다.
- 오버라이딩 할 수 없는 final 메소드: 메소드를 선언할 때 final 키워드를 붙이게 되면 이 메소드는 최종적인 메서드이므로 오버라이딩을 할 수 없는 메소드가 된다. 
<br>

#### 4-1. 상수(static final)
- static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다. 그리고 한번 초기값이 저장되면 변경할 수 없다.

<br><br>

## 5. 접근 제한자  
| 접근제한자 | 적용 대상 | 접근할 수 없는 클래스 |
|:-----|:----|:----|
| public | 클래스,필드,생성자,메소드 | 없음 |
| protected | 필드,생성자,메소드 | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default | 클래스,필드,생성자,메소드 | 다른 패키지에 소속된 클래스 |
| private | 필드,생성자,메소드 | 모든 외부 클래스 |

<br>


---
#### 참고
[이것이 자바다 신용권의 Java 프로그래밍 정복]() <br>